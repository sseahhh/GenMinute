{% extends "layout.html" %}

{% block title %}마인드맵 생성 테스트{% endblock %}

{% block content %}
<main class="content-panel">
    <header class="content-header">
        <h1>마인드맵 생성 테스트</h1>
        <p style="color: #666; font-size: 0.9rem; margin-top: 0.5rem;">텍스트/STT → 요약 → 회의록 → 마인드맵</p>
    </header>

    <div style="max-width: 1400px; margin: 0 auto; padding: 2rem;">
        <!-- 이전 단계 알림 -->
        <div id="previous-step-notice" style="display: none; padding: 1rem; background: #d4edda; border: 1px solid #c3e6cb; border-radius: 6px; margin-bottom: 1.5rem; color: #155724;">
            <strong>✅ 이전 단계 데이터 자동 로드됨</strong>
            <span id="previous-step-text"></span>
        </div>
        <!-- 예시 선택 -->
        <div class="form-group">
            <label for="example-select">예시 선택 (선택하면 자동으로 입력됩니다)</label>
            <select id="example-select" class="form-select" style="width: 100%; padding: 0.75rem; border: 1px solid #ddd; border-radius: 6px; font-size: 1rem;">
                <option value="">직접 입력</option>
                <option value="example1">예시 1: AI 챗봇 개발 계획</option>
                <option value="example2">예시 2: 웹 서비스 개선</option>
                <option value="example3">예시 3: 마이크로서비스 전환</option>
                <option value="example4">예시 4: 스프린트 회고</option>
                <option value="example5">예시 5: 예산 배정 회의</option>
            </select>
        </div>

        <!-- 텍스트 입력 -->
        <div class="form-group" style="margin-top: 1.5rem;">
            <label for="input-text">문단 요약 텍스트 (주제별로 정리된 요약문)</label>
            <textarea id="input-text" rows="15" placeholder="요약 텍스트를 입력하세요...&#10;&#10;형식 예시:&#10;# 주제 1&#10;주제 1에 대한 요약 내용입니다.&#10;&#10;# 주제 2&#10;주제 2에 대한 요약 내용입니다." style="width: 100%; padding: 1rem; border: 2px solid #ddd; border-radius: 8px; font-family: 'Pretendard', -apple-system, sans-serif; font-size: 0.95rem; line-height: 1.6; resize: vertical;"></textarea>
        </div>

        <!-- 버튼 -->
        <div style="margin-top: 1.5rem; text-align: center;">
            <button id="generate-btn" class="btn-primary" style="padding: 0.75rem 3rem; font-size: 1rem;">마인드맵 생성</button>
        </div>

        <!-- 결과 -->
        <div id="result-section" style="margin-top: 3rem; display: none;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                <h2 style="margin: 0;">생성된 마인드맵</h2>
                <div>
                    <button id="download-btn" class="btn-secondary" style="padding: 0.5rem 1.5rem; margin-right: 0.5rem;">SVG 다운로드</button>
                    <button id="copy-markdown-btn" class="btn-secondary" style="padding: 0.5rem 1.5rem;">마크다운 복사</button>
                </div>
            </div>
            <div id="mindmap-container" style="background: #fff; border: 2px solid #dee2e6; border-radius: 8px; height: 600px; overflow: hidden;">
                <svg id="mindmap-svg" style="width: 100%; height: 100%;"></svg>
            </div>
        </div>

        <!-- 로딩 -->
        <div id="loading-section" style="margin-top: 3rem; text-align: center; display: none;">
            <div class="spinner" style="margin: 2rem auto; width: 50px; height: 50px; border: 4px solid #f3f3f3; border-top: 4px solid #3498db; border-radius: 50%; animation: spin 1s linear infinite;"></div>
            <p style="color: #666; font-size: 1.1rem;">마인드맵을 생성하고 있습니다...</p>
        </div>
    </div>
</main>

<!-- Markmap 라이브러리 (viewer.html과 동일) -->
<script src="https://cdn.jsdelivr.net/npm/markmap-autoloader"></script>

<script>
// 페이지 로드 시 이전 단계 데이터 자동 로드
window.addEventListener('DOMContentLoaded', () => {
    const minutesData = sessionStorage.getItem('pipeline_minutes_result');
    const summaryData = sessionStorage.getItem('pipeline_summary_result');
    const previousStep = sessionStorage.getItem('pipeline_step');

    // 회의록 결과 우선 (더 최신 단계)
    if (minutesData && previousStep === 'minutes') {
        document.getElementById('input-text').value = minutesData;
        document.getElementById('previous-step-notice').style.display = 'block';
        document.getElementById('previous-step-text').textContent = ' (회의록 결과)';
        console.log('✅ 이전 단계 데이터 자동 로드 완료 (회의록)');
    } else if (summaryData && previousStep === 'summary') {
        document.getElementById('input-text').value = summaryData;
        document.getElementById('previous-step-notice').style.display = 'block';
        document.getElementById('previous-step-text').textContent = ' (요약 결과)';
        console.log('✅ 이전 단계 데이터 자동 로드 완료 (요약)');
    }
});

// 예시 텍스트 데이터 (이미 요약된 형식)
const exampleTexts = {
    "example1": `# AI 챗봇 개발 계획

사용자 FAQ 자동 응답을 위한 AI 챗봇 기능을 신규 모바일 앱에 추가하기로 결정했습니다. 월 평균 1만 건의 FAQ 조회를 자동화하여 고객센터 부담을 줄이고 사용자 만족도를 향상시키는 것이 목표입니다.

# 기술 스택 선정

GPT-4, Claude, Gemini 세 가지 모델을 모두 테스트하여 비용 대비 성능을 비교하기로 했습니다. GPT-4는 응답 품질이 우수하지만 월 200만원의 비용이 예상되어, 더 저렴한 대안도 검토 중입니다.

# 개발 일정

이번 주에 프로토타입 개발, 다음 주에 내부 테스트, 그 다음 주에 베타 오픈을 목표로 3주 일정을 계획했습니다. 다음 회의에서 프로토타입 데모를 공유할 예정입니다.

# 보안 및 개인정보 보호

사용자 질문이 외부 API로 전송되므로 개인정보가 포함된 질문은 필터링하고, 모든 데이터는 암호화하여 전송할 계획입니다. 데이터 보안을 최우선으로 고려하고 있습니다.`,

    "example2": `# UI 리뉴얼

사용자 피드백을 반영하여 메인 대시보드 UI를 전면 개편합니다. 다크 모드 지원, 반응형 디자인 적용, 접근성 개선을 주요 목표로 하며 Figma 디자인은 이번 주 내 완성 예정입니다.

# 성능 최적화

페이지 로딩 속도를 현재 3초에서 1초 이내로 단축하는 것을 목표로 합니다. 이미지 레이지 로딩, CDN 도입, 데이터베이스 쿼리 최적화를 통해 성능을 개선할 계획입니다.

# 모바일 대응

모바일 트래픽이 전체의 60%를 차지하므로 모바일 최적화가 시급합니다. PWA 기술을 도입하여 앱과 유사한 사용자 경험을 제공하고, 오프라인 모드도 지원할 예정입니다.

# 사용자 피드백 수집

새로운 기능에 대한 사용자 만족도를 측정하기 위해 인앱 설문조사와 Google Analytics를 활용합니다. A/B 테스트를 통해 최적의 UI/UX를 찾아갈 계획입니다.`,

    "example3": `# 현재 시스템 문제점

모놀리식 아키텍처로 인해 배포 시간이 오래 걸리고, 한 부분의 문제가 전체 시스템에 영향을 미칩니다. 팀별 독립적인 개발이 어려워 생산성이 저하되고 있습니다.

# 마이크로서비스 전환 계획

Kubernetes와 Istio를 활용하여 마이크로서비스 아키텍처로 전환합니다. 각 서비스마다 독립적인 DB를 사용하고, 데이터 동기화는 이벤트 기반으로 처리할 예정입니다.

# 성능 및 최적화

초기 네트워크 오버헤드 문제는 캐싱과 로드 밸런싱으로 해결합니다. 각 서비스의 독립적인 스케일링이 가능해져 전체적인 성능이 향상될 것으로 예상됩니다.

# 마이그레이션 일정

3개월 계획으로 먼저 인증 서비스부터 분리하고, 순차적으로 다른 모듈들을 전환합니다. 각 서비스별 단위 테스트를 강화하고 통합 테스트는 컨테이너 환경에서 자동화합니다.`,

    "example4": `# 스프린트 성과

코드 리뷰 프로세스 개선으로 배포 전 버그 발견율이 크게 증가했습니다. PR 템플릿 도입으로 리뷰어가 체크할 항목이 명확해졌으며, 팀 전체의 코드 품질이 향상되었습니다.

# 개선 필요 사항

스프린트 중간의 잦은 요구사항 변경으로 일정 관리에 어려움이 있었습니다. 기획팀과의 소통 부족이 원인으로 파악되어, 다음 스프린트부터는 일일 스탠드업에 기획팀도 참여하기로 했습니다.

# 테스트 커버리지 개선

목표 80%에 미달한 65%의 테스트 커버리지를 달성했습니다. 시간 부족이 주요 원인이었으며, 다음 스프린트에서는 TDD 방식을 도입하여 개발과 동시에 테스트 코드를 작성할 계획입니다.

# 팀원 피드백

성능 최적화로 페이지 로딩 시간을 절반으로 줄인 것과 신규 기능 출시 후 긍정적인 사용자 피드백을 받은 것이 가장 보람 있었다는 의견이 있었습니다.`,

    "example5": `# 부서별 예산 요청

개발팀은 서버 인프라 확장, 라이선스, 교육비로 총 2억원을 요청했습니다. 마케팅팀은 광고비와 프로모션으로 1억 5천만원, 인사팀은 채용 및 복리후생으로 5천만원을 요청했습니다.

# 예산 제약 및 조정

총 4억원이 요청되었으나 배정 가능 예산은 3억원입니다. 우선순위를 고려하여 개발팀 교육비를 다음 분기로 이연하고, 마케팅팀 이벤트 예산을 축소하기로 했습니다.

# 최종 배정 결과

개발팀 1억 5천만원(서버 인프라 위주), 마케팅팀 1억 2천만원(광고비 중심), 인사팀 3천만원으로 총 3억원을 배정했습니다. 모든 부서가 조정안에 동의했습니다.

# 향후 계획

다음 분기에 이연된 개발팀 교육비와 마케팅팀 이벤트 예산을 우선 검토하기로 했습니다. 각 부서는 분기별로 예산 집행 현황을 보고할 예정입니다.`
};

let markmapInstance = null;
let currentMarkdown = '';

// 예시 선택 시 텍스트 자동 입력
document.getElementById('example-select').addEventListener('change', (e) => {
    const selectedKey = e.target.value;
    const textarea = document.getElementById('input-text');

    if (selectedKey && exampleTexts[selectedKey]) {
        textarea.value = exampleTexts[selectedKey];
    } else {
        textarea.value = '';
    }
});

// 마인드맵 생성 버튼
document.getElementById('generate-btn').addEventListener('click', async () => {
    const text = document.getElementById('input-text').value.trim();

    if (!text) {
        alert('텍스트를 입력해주세요.');
        return;
    }

    // 로딩 표시
    document.getElementById('result-section').style.display = 'none';
    document.getElementById('loading-section').style.display = 'block';

    try {
        const response = await fetch('/api/test_mindmap', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                summary_text: text,
                title: '테스트 회의'
            })
        });

        const data = await response.json();

        if (data.success) {
            // 마크다운 저장
            currentMarkdown = data.mindmap;

            // Markmap 렌더링
            renderMarkmap(data.mindmap);

            // 결과 표시
            document.getElementById('result-section').style.display = 'block';
        } else {
            alert('마인드맵 생성 실패: ' + (data.error || '알 수 없는 오류'));
        }
    } catch (error) {
        console.error('마인드맵 생성 오류:', error);
        alert('마인드맵 생성 중 오류가 발생했습니다.');
    } finally {
        document.getElementById('loading-section').style.display = 'none';
    }
});

// 간단한 마크다운 파싱 함수 (폴백용 - viewer.js에서 복사)
function parseMarkdownToTree(markdown) {
    const lines = markdown.split('\n').filter(line => line.trim());
    let root = null;
    let stack = [];

    lines.forEach(line => {
        const trimmed = line.trim();

        // 제목 파싱 (# ## ### 등)
        const headingMatch = trimmed.match(/^(#{1,6})\s+(.+)$/);
        if (headingMatch) {
            const level = headingMatch[1].length;
            const content = headingMatch[2];

            const node = {
                type: 'heading',
                depth: level,
                content: content,
                children: []
            };

            // 첫 번째 # (depth=1) 노드를 root로 설정
            if (level === 1 && root === null) {
                root = node;
                stack = [root];
                return;
            }

            // 적절한 부모 찾기
            while (stack.length > 0 && stack[stack.length - 1].depth >= level) {
                stack.pop();
            }

            if (stack.length > 0) {
                stack[stack.length - 1].children.push(node);
                stack.push(node);
            }
        }

        // 리스트 아이템 파싱 (- 또는 *)
        const listMatch = trimmed.match(/^[-*]\s+(.+)$/);
        if (listMatch) {
            const content = listMatch[1];
            const node = {
                type: 'list_item',
                depth: stack.length > 0 ? stack[stack.length - 1].depth + 1 : 1,
                content: content,
                children: []
            };

            if (stack.length > 0) {
                stack[stack.length - 1].children.push(node);
            }
        }
    });

    return root;
}

// Markmap 렌더링 함수 (viewer.js와 동일한 방식)
async function renderMarkmap(markdown) {
    try {
        const svg = document.getElementById('mindmap-svg');

        // Markmap 라이브러리 로드 대기
        if (typeof window.markmap === 'undefined') {
            console.log('⏳ Markmap 라이브러리 로딩 대기 중...');
            let retries = 0;
            while (typeof window.markmap === 'undefined' && retries < 30) {
                await new Promise(resolve => setTimeout(resolve, 100));
                retries++;
            }

            if (typeof window.markmap === 'undefined') {
                throw new Error('Markmap 라이브러리를 로드할 수 없습니다.');
            }
        }

        // Markmap 렌더링
        const { Markmap } = window.markmap;

        // Transformer 사용
        let root;
        if (window.markmap.transform) {
            const { transform } = window.markmap;
            const transformer = transform(markdown);
            root = transformer.root;
        } else {
            // 폴백: 간단한 파싱
            console.warn('⚠️ Markmap transform을 사용할 수 없어 기본 모드로 렌더링합니다.');
            root = parseMarkdownToTree(markdown);
        }

        // 기존 인스턴스 제거
        if (markmapInstance) {
            markmapInstance.destroy();
        }

        // 새 인스턴스 생성
        markmapInstance = Markmap.create(svg, {
            color: (node) => {
                const colors = ['#4A90E2', '#50C878', '#F39C12', '#9B59B6', '#E74C3C', '#1ABC9C'];
                return colors[node.depth % colors.length];
            }
        }, root);

        console.log('✅ 마인드맵 렌더링 완료');

    } catch (error) {
        console.error('❌ 마인드맵 렌더링 실패:', error);
        alert('마인드맵 렌더링에 실패했습니다: ' + error.message);
    }
}

// SVG 다운로드 버튼
document.getElementById('download-btn').addEventListener('click', () => {
    const svg = document.getElementById('mindmap-svg');
    const svgData = new XMLSerializer().serializeToString(svg);
    const blob = new Blob([svgData], { type: 'image/svg+xml' });
    const url = URL.createObjectURL(blob);

    const a = document.createElement('a');
    a.href = url;
    a.download = 'mindmap.svg';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);

    alert('SVG 파일이 다운로드되었습니다!');
});

// 마크다운 복사 버튼
document.getElementById('copy-markdown-btn').addEventListener('click', () => {
    if (!currentMarkdown) {
        alert('먼저 마인드맵을 생성해주세요.');
        return;
    }

    navigator.clipboard.writeText(currentMarkdown).then(() => {
        alert('마크다운이 복사되었습니다!');
    }).catch(err => {
        console.error('복사 실패:', err);
        alert('복사에 실패했습니다.');
    });
});
</script>

<style>
@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

.form-group label {
    display: block;
    margin-bottom: 0.5rem;
    font-weight: 600;
    color: #333;
}
</style>
{% endblock %}
